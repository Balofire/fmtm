<!-- Copyright (c) 2020, 2021, 2022 Humanitarian OpenStreetMap Team
# This file is part of FMTM.
#
#     FMTM is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     FMTM is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with FMTM.  If not, see <https:#www.gnu.org/licenses/>.
# -->

{% extends 'base.html' %}

{% block header %}
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

<h1>{% block title %}Pick Task for "{{ project_name }}"{% endblock %}</h1>
{% endblock %}

{% block content %}
{% if message %}
<p id="quick_view">{{message}}</p>
{% endif %}


<div style="width: 100%; height: 30rem">
  <div id="map" style="float:left; width: 97%; height: 100%">
    <!--  <div class="leaflet-bottom leaflet-left">
      <img id="center_project" src="/static/Expand_Map.svg"
        style="width: 3rem; height: 3rem; margin: 3rem 0rem 0rem 0rem;" />
    </div>  -->
  </div>
  <div id="map-buttons" style="float:right; width: 3%; height: 100%">
    <img id="center_project" src="/static/Expand_Map.svg" style="width: 2rem; height: 2rem; margin: 0.25rem;" />
    <img id="zoom_to_location" src="/static/GPS_Found.svg" style="width: 2rem; height: 2rem; margin: 0.25rem;" />

  </div>

</div>


<h2>My tasks</h1>
  {% for task in tasks %}
  {% if (task.locked_by_uid == userid) %}
  <article class="project">
    <header>
      <div>
        <h3 class="task-{{task.uid}}-title"> Task {{ task.name }}
</h2>
<p>Status: {{ task.status }}</p>

<h4>Task History</h4>
{% for history in task.task_history %}
<p>{{history.date}}</p>
<p>{{history.action_str}}</p>
<p>---</p>
{% endfor %}

<!--  <p>QR Code: {{ task.qr_code}} </p>  
      <img class="list-qr" id="qr_task_{{task.uid}}" src="data:image/png;base64,{{task.qr_code}}"> -->
</div>
</header>
</article>
<hr>
{% endif %}
{% endfor %}

<h2>Project tasks</h1>
  {% for task in tasks %}
  <article class="project">
    <header>
      <div>
        <h3 class="task-{{task.uid}}-title">Task {{ task.name }}
</h2>
<p>Status: {{ task.status }}</p>
{% if (task.locked_by_uid > -1) %}
<p>Locked by: {{ task.locked_by_name }}</p>
{% endif %}


{% for history in task.task_history %}
<p>{{history.date}}</p>
<p>{{history.action_str}}</p>
<p>---</p>
{% endfor %}

<!--  <p>QR Code: {{ task.qr_code}} </p>  
      <img class="list-qr" id="qr_task_{{task.uid}}" src="data:image/png;base64,{{task.qr_code}}"> -->
</div>
</header>
</article>
{% if not loop.last %}
<hr>
{% endif %}
{% endfor %}


<link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css"
  integrity="sha512-hoalWLoI8r4UszCkZ5kL8vayOGVae1oxXe/2A4AO6J9+580uKHDO3JdHb7NzwwzK5xr/Fs0W40kiNHxM9vyTtQ=="
  crossorigin="" />

<!-- Make sure you put this AFTER Leaflet's CSS -->
<script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js"
  integrity="sha512-BB3hKbKWOc9Ez/TAwyWxNXeoV9c1v6FIeYiBieIWkpLjauysF18NzgR1MBNBXf8/KABdlkX68nAhlwcDFLGPCQ=="
  crossorigin=""></script>

<!-- responseive Leaflet popups -->
<link rel="stylesheet" href="https://unpkg.com/leaflet-responsive-popup@1.0.0/leaflet.responsive.popup.css" />
<script src="https://unpkg.com/leaflet-responsive-popup@1.0.0/leaflet.responsive.popup.js"></script>

<!-- geocoding -->
<script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

<script>
  /*  var p_outline = {
    "type": "FeatureCollection",
    "name": "Naivasha",
    "crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:OGC:1.3:CRS84" } },
    "features": [
      { "type": "Feature", "properties": {}, "geometry": { "type": "Polygon", "coordinates": [[[36.441132294546918, -0.748127689869466], [36.431360797266251, -0.769253399198293], [36.427318119597118, -0.7777442799901], [36.426607095886474, -0.779552144753597], [36.427114969965508, -0.779846684444971], [36.433991584995674, -0.77968417979021], [36.433778277882475, -0.780303728752816], [36.430888474372743, -0.785839039197057], [36.428511623682851, -0.790257125758318], [36.427186072336582, -0.792232567541131], [36.426200796623256, -0.79395917398364], [36.423336386817475, -0.798925702607457], [36.422310481177838, -0.800378081010835], [36.418826464995654, -0.803374244622618], [36.417963079061288, -0.805232880606962], [36.419425756408913, -0.8059743034682], [36.422462843401547, -0.807101672217701], [36.424138827862365, -0.803770347444342], [36.427795521231431, -0.801688268080342], [36.427978355899882, -0.802744542621881], [36.429613710434381, -0.803008611214652], [36.434245522035198, -0.803008611214652], [36.440868200025839, -0.805446166649357], [36.447694027648076, -0.808076693586922], [36.450741272122293, -0.809417347587404], [36.455169934091494, -0.808401700657998], [36.460533084366126, -0.806695413244867], [36.464606234480001, -0.805903208131183], [36.463590486321934, -0.801881241334254], [36.462280171198017, -0.797554575671596], [36.461335525411016, -0.794527938301015], [36.456084107433767, -0.786098030607428], [36.454753477346685, -0.782908880358569], [36.452782925920033, -0.777404035692344], [36.451452295832958, -0.773778146997981], [36.445550799034557, -0.760254672171128], [36.443890050796099, -0.755379507470098], [36.441431940253565, -0.74818355125548], [36.441132294546918, -0.748127689869466]]] } }
    ]
  }  */

  var p_outline = {{(project_outline |default ({}))| tojson }};
  var logged_in_user = {{ userid }}
  var open_task_id = {{ open_task_id }}
  var outline_layer

  function centerOnMap() {
    // zoom to map
    map.fitBounds(outline_layer.getBounds());
  }

  function setMap() {
    var map = L.map('map', {
      zoomSnap: 0.1
    });
    const osm = L.tileLayer(
      "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
      {
        attribution:
          '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        maxNativeZoom: 19,
        maxZoom: 25
      }
    ).addTo(map);

    return map;
  }

  function addOutline() {
    // add outline
    outline_layer = L.geoJSON(p_outline);
    outline_layer.setStyle({
      color: '#e0e0e0',
      weight: 3,
      fillOpacity: 0.5,
      fillColor: 'rgb(255, 255, 255)'
    })
    outline_layer.addTo(map);

    // zoom to map
    map.fitBounds(outline_layer.getBounds());
  }

  map = setMap();
  addOutline();

  document.getElementById("center_project").onclick = function () {
    centerOnMap()
  }

  document.getElementById("zoom_to_location").onclick = function () {
    if (locationFeatureGroup == null) {
      //navigator.geolocation.getCurrentPosition(getPosition)
      map.locate({ setView: true, maxZoom: 16 });
      addLocationWatcherToMap()
    }
    else {
      map.fitBounds(locationFeatureGroup.getBounds())
    }
  }

  function onLocationFound(e) {
    if (locationFeatureGroup == null) {
      addLocationFeatureGroup(e.latlng, e.accuracy)
    }
  }

  function onLocationError(e) {
    alert(e.message);
  }

  //map.on('locationerror', onLocationError);
  map.on('locationfound', onLocationFound);

  //L.Control.geocoder().addTo(map);
  function addLocationWatcherToMap() {
    if (!navigator.geolocation) {
      console.log("Your browser doesn't support geolocation feature!")
    } else {
      console.log("Google recommends not finding user location on page load, but as it is important for the useability of this app, we're ignoring the warning.")
      navigator.geolocation.watchPosition(getPosition, onLocationError);
    };
  }
  var locationFeatureGroup, locationMarker, locationCircle, lat, long, accuracy;

  function getPosition(position) {
    // console.log(position)
    lat = position.coords.latitude
    long = position.coords.longitude
    accuracy = position.coords.accuracy

    if (locationMarker) {
      map.removeLayer(locationMarker)
    }

    if (locationCircle) {
      map.removeLayer(locationCircle)
    }

    addLocationFeatureGroup([lat, long], accuracy)
  }

  function addLocationFeatureGroup(latlng, radius) {
    locationMarker = L.circle(latlng, { radius: 1 })
    locationMarker.bindPopup("You are within " + radius + " meters from this point")
    if (accuracy != null) {
      locationCircle = L.circle(latlng, { radius: accuracy })
      locationFeatureGroup = L.featureGroup([locationMarker, locationCircle]).addTo(map)
      locationFeatureGroup.bringToBack();
    } else {
      locationFeatureGroup = L.featureGroup([locationMarker]).addTo(map)
    }

  }

  const READY = 'READY';
  const LOCKED_FOR_MAPPING = 'LOCKED_FOR_MAPPING';
  const MAPPED = 'MAPPED';
  const LOCKED_FOR_VALIDATION = 'LOCKED_FOR_VALIDATION';
  const VALIDATED = 'VALIDATED';
  const INVALIDATED = 'INVALIDATED';
  const BAD = 'BAD';
  const SPLIT = 'SPLIT';

  function getColor(statusValue) {
    bg = 'rgb(255, 255, 255)' // set to white
    switch (statusValue) {
      case READY:
        //bg = 'rgb(153, 204, 255)'
        bg = 'rgb(102, 229, 255)'
        break;
      case LOCKED_FOR_MAPPING:
        //bg = 'rgb(140, 146, 172)'
        bg = 'rgb(102, 175, 255)'
        break;
      case MAPPED:
        //bg = 'rgb(255, 255, 0)'
        bg = 'rgb(32, 35, 149)'
        break;
      case LOCKED_FOR_VALIDATION:
        //bg = 'rgb(248, 240, 227)'
        bg = 'rgb(112, 73, 222)'
        break;
      case VALIDATED:
        //bg = 'rgb(76, 153, 0)'
        bg = 'rgb(0, 102, 0)'
        break;
      case INVALIDATED:
        //bg = 'rgb(102, 0, 102)'
        bg = 'rgb(255, 255, 0)'
        break;
      case BAD:
        //bg = 'rgb(153, 0, 0)'
        bg = 'rgb(223, 202, 202)'
        break;
      case SPLIT:
        //bg = 'rgb(102, 51, 0)'
        bg = 'rgb(223, 202, 202)'
        break;
      default:
        bg = 'rgb(216, 218, 228)' //set to unavailable
        break;
    }
    return bg
  }

  function getStyle(statusValue) {
    bg = getColor(statusValue)

    return {
      color: '#404040',
      weight: 1,
      fillOpacity: 0.25,
      fillColor: bg
    }
  }

  var grayLockIcon = L.icon({
    iconUrl: "/static/lock_icon_gray.png",
    iconSize: [10, 10], // size of the icon
  });

  var blackLockIcon = L.icon({
    iconUrl: "/static/lock_icon.png",
    iconSize: [10, 10], // size of the icon
  });

  var popupOptions = {
    'maxWidth': '500',
    'className': 'fmtm-popup' // classname for another popup
  }

  function createTaskDetails(task) {
    return `<h1>Task ${task.name}</h1>
            <p>Status: ${task.status}</p>`
  }

  function createUpdateStatusButton(task, new_status, new_status_label) {
    return `<form action="${task.url}" method="post">
      <button name="updateButton" type="submit" value="${new_status}">${new_status_label}</button>
    </form>`
  }

  function createFullDetailButton(task) {
    return `<form action="${task.url}" method="get">
      <button class="secondary" name="detailsButton" type="submit" value=${task.uid}>View Task Json</button>
    </form>`
  }

  function createQrCode(task) {
    const uid = task.uid;
    const name = task.name;
    const qr_binary = task.qr;
    return `<img class="popup-qr" id="qr_task_${uid}" src="data:image/png;base64,${qr_binary}" download='FMTM_Task_${uid}_QR_CODE.png'>
    <a href="data:image/png;base64,${qr_binary}" download="FMTM_Task_${name}_QR_CODE.png">
      <button class="secondary" onclick="downloadQr(${uid},'${qr_binary}')">Download QR Code</button>
    </a>     `
  }

  function downloadQr(name, qr) {
    console.log(`About to download... ${name}`)

    const imageURL = URL.createObjectURL(qr)
  }

  function createReadyPopup(task) {
    return L.popup().setContent(
      `<div class='fmtm-popup-div' width: auto; maxWidth: 450; height: window.innerHeight>
                  ${createTaskDetails(task)}
                  ${createUpdateStatusButton(task, LOCKED_FOR_MAPPING, "Start Mapping")}
                  ${createFullDetailButton(task)}
                </div>`
    )
  }

  function createLockedForMappingByMePopup(task) {
    return L.popup().setContent(
      `<div class='fmtm-popup-div' width: auto; height: window.innerHeight>
                  ${createTaskDetails(task)}
                  ${createQrCode(task)}
                  ${createUpdateStatusButton(task, MAPPED, "Mark as fully mapped")}
                  ${createUpdateStatusButton(task, READY, "Give this task to someone else")}
                  ${createFullDetailButton(task)}
                </div>`
    )
  }

  function createLockedPopup(task) {
    return L.popup().setContent(
      `<div class='fmtm-popup-div' width: auto; height: window.innerHeight>
                  ${createTaskDetails(task)}
                  ${createFullDetailButton(task)}
                </div>`
    )
  }

  function createMappedPopup(task) {
    return L.popup().setContent(
      `<div class='fmtm-popup-div' width: auto; height: window.innerHeight>
                  ${createTaskDetails(task)}
                  ${createUpdateStatusButton(task, LOCKED_FOR_VALIDATION, "Start validating")}
                  ${createUpdateStatusButton(task, LOCKED_FOR_MAPPING, "Return to mapping")}
                  ${createFullDetailButton(task)}
                </div>`
    )
  }

  function createLockedForValidationPopup(task) {
    // TODO check validator
    return L.popup().setContent(
      `<div class='fmtm-popup-div' width: auto; height: window.innerHeight>
                  ${createTaskDetails(task)}
                  ${createUpdateStatusButton(task, VALIDATED, "Confirm fully mapped")}
                  ${createUpdateStatusButton(task, INVALIDATED, "More mapping needed")}
                  ${createUpdateStatusButton(task, MAPPED, "I don't want to verify this task")}
                  ${createFullDetailButton(task)}
                </div>`
    )
  }

  function createValidatedPopup(task) {
    return L.popup().setContent(
      `<div class='fmtm-popup-div' width: auto; height: window.innerHeight>
                  ${createTaskDetails(task)}
                  ${createFullDetailButton(task)}
                </div>`
    )
  }

  function createInvalidatedPopup(task) {
    return L.popup().setContent(
      `<div class='fmtm-popup-div' width: auto; height: window.innerHeight>
                  ${createTaskDetails(task)}
                  ${createUpdateStatusButton(task, LOCKED_FOR_MAPPING, "Map again")}
                  ${createFullDetailButton(task)}
                </div>`
    )
  }

  function removeMarker(marker) {
    if (isNaN(marker) | isNaN(map)) {
      return
    }
    map.removeLayer(marker)
  }

  function addLockedMark(where, icon, popup, popupOptions) {
    marker = L.marker(where, { icon: icon })
    marker.addTo(map)
    marker.bindPopup(popup, popupOptions)
    return marker
  }

  function createTaskLayer(task) {
    layer = L.geoJSON(task.outline);
    layer.addTo(map);

    layer.setStyle(getStyle(jsTask.status))
    task.layer = layer;

    switch (task.status) {
      case READY:
        task.popup = createReadyPopup(task)
        removeMarker(task.marker)
        break;
      case LOCKED_FOR_MAPPING:
        if (task.is_locked_by_me) {
          task.popup = createLockedForMappingByMePopup(task)
          addLockedMark(task.centroid, blackLockIcon, task.popup, popupOptions)
        } else {
          task.popup = createLockedPopup(task)
          addLockedMark(task.centroid, grayLockIcon, task.popup, popupOptions)
        }
        break;
      case MAPPED:
        task.popup = createMappedPopup(task)
        removeMarker(task.marker)
        break;
      case LOCKED_FOR_VALIDATION:
        if (task.is_locked_by_me) {
          task.popup = createLockedForValidationPopup(task)
          addLockedMark(task.centroid, blackLockIcon, task.popup, popupOptions)
        } else {
          task.popup = createLockedPopup(task)
          addLockedMark(task.centroid, grayLockIcon, task.popup, popupOptions)
        }
        break;
      case VALIDATED:
        task.popup = createValidatedPopup(task)
        removeMarker(task.marker)
        break;
      case INVALIDATED:
        task.popup = createInvalidatedPopup(task)
        removeMarker(task.marker)
        break;
      default:
        task.popup = createLockedPopup(task) // default popup
        break;
    }
    layer.bindPopup(task.popup, popupOptions)

    if (open_task_id == task.uid) {
      task.layer.openPopup();
    }
  }

  function styleElements(task) {
    titles = document.getElementsByClassName(`task-${task.uid}-title`)
    if (titles.length > 0) {
      //console.log(titles)
    }
    for (let i = 0; i < titles.length; i++) {
      //console.log(titles[i])
      var color = getColor(task.status)
      if (titles[i] != null) {
        titles[i].style.borderLeft = `1rem solid ${color}`;
      }
    }
  }

  // Declaration
  class MappedTask {
    uid;
    name;
    status;
    locked_by = NaN;
    outline;
    centroid;
    qr;
    url;
    is_locked_by_me
    layer = NaN;
    popum = NaN;
    marker = NaN;


    constructor(task_uid, name, task_status, locked_by, is_locked_by_me, task_outline, task_centroid, task_qr, task_action_url) {
      this.uid = task_uid;
      this.name = name;
      this.status = task_status;
      this.locked_by = locked_by;
      this.is_locked_by_me = is_locked_by_me;
      this.outline = task_outline;
      this.centroid = task_centroid;
      this.qr = task_qr;
      this.url = task_action_url;

    }
  }

  var task_uid
  var task_name
  var task_status
  var task_locked_uid
  var task_is_locked_by_me
  var task_outline
  var task_centroid_lat
  var task_centroid_long
  var task_centroid

  var task_action_url
  var jsTask

  {% for task in tasks %}

  task_uid = {{ task.uid }}
  task_name = '{{ task.name }}'
  task_status = {{ task.status }}
  task_locked_name = '{{ task.locked_by_name }}'
  task_locked_uid = {{ task.locked_by_uid }}
  is_mine = parseInt(task_locked_uid) == parseInt(logged_in_user)
  task_outline = {{ (task.outline |default ({}))| tojson }};
  task_qr = "{{ task.qr_code }}"
  task_centroid_lat = {{ task.centroid_lat }}
  task_centroid_long = {{ task.centroid_long }}
  task_centroid = [task_centroid_long, task_centroid_lat]

  task_action_url = {{
    url_for('project.update_task_status', task_uid = task.uid) | tojson
  }}

  jsTask = new MappedTask(task_uid, task_name, task_status, task_locked_name, is_mine, task_outline, task_centroid, task_qr, task_action_url)

  createTaskLayer(jsTask);
  styleElements(jsTask);

  {% endfor %}

</script>
{% endblock %}